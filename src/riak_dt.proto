/* -------------------------------------------------------------------
**
** riak_dt.proto: Protocol buffers for Riak data structures/types
**
** Copyright (c) 2013 Basho Technologies, Inc.  All Rights Reserved.
**
** This file is provided to you under the Apache License,
** Version 2.0 (the "License"); you may not use this file
** except in compliance with the License.  You may obtain
** a copy of the License at
**
**   http://www.apache.org/licenses/LICENSE-2.0
**
** Unless by applicable law or agreed to in writing,
** software distributed under the License is distributed on an
** "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
** KIND, either express or implied.  See the License for the
** specific language governing permissions and limitations
** under the License.
**
** -------------------------------------------------------------------
*/

/*
** Revision: 2.2.0
*/

syntax = "proto3";
package basho.riak.api.pb.message;

// Java package specifiers
option java_package = "com.basho.riak.protobuf";
option java_outer_classname = "RiakDtPB";

/*
 * =============== DATA STRUCTURES =================
 */

/*
 * Field names in maps are composed of a binary identifier and a type.
 * This is so that two clients can create fields with the same name
 * but different types, and they converge independently.
 */
message MapField {
    /*
     * The types that can be stored in a map are limited to counters,
     * sets, registers, flags, and maps.
     */
    enum MapFieldType {
        DEFAULT = 0;
        COUNTER  = 1;
        SET      = 2;
        REGISTER = 3;
        FLAG     = 4;
        MAP      = 5;
    }

    bytes        name = 1;
    MapFieldType type = 2;
}


/*
 * An entry in a map is a pair of a field-name and value. The type
 * defined in the field determines which value type is expected.
 */
message MapEntry {
    MapField field = 1;
    sint64   counter_value  = 2;
    repeated bytes    set_value      = 3;
    bytes    register_value = 4;
    bool     flag_value     = 5;
    repeated MapEntry map_value      = 6;
}

/*
 * =============== FETCH =================
 */

/*
 * The equivalent of KV's "RpbGetReq", results in a DtFetchResp. The
 * request-time options are limited to ones that are relevant to
 * structured data-types.
 */
message DtFetchReq {
    // The identifier: bucket, key and bucket-type
    bytes bucket = 1;
    bytes key    = 2;
    bytes type  = 3;

    // Request options
    uint32 r             =  4;
    uint32 pr            =  5;
    bool   basic_quorum  =  6;
    bool   notfound_ok   =  7;
    uint32 timeout       =  8;
    bool   sloppy_quorum =  9;  // Experimental, may change/disappear
    uint32 n_val         = 10;  // Experimental, may change/disappear

    // For read-only requests or context-free operations, you can set
    // this to false to reduce the size of the response payload.
    bool include_context = 11;
}


/*
 * The value of the fetched data type. If present in the response,
 * then empty values (sets, maps) should be treated as such.
 */
message DtValue {
    sint64   counter_value = 1;
    repeated bytes    set_value     = 2;
    repeated MapEntry map_value     = 3;

    /* We return an estimated cardinality of the Hyperloglog set
     * on fetch.
     */
    uint64   hll_value     = 4;
}


/*
 * The response to a "Fetch" request. If the `include_context` option
 * is specified, an opaque "context" value will be returned along with
 * the user-friendly data. When sending an "Update" request, the
 * client should send this context as well, similar to how one would
 * send a vclock for KV updates. The `type` field indicates which
 * value type to expect. When the `value` field is missing from the
 * message, the client should interpret it as a "not found".
 */
message DtFetchResp {
    enum DataType {
        DEFAULT = 0;
        COUNTER = 1;
        SET     = 2;
        MAP     = 3;
        HLL     = 4;
    }

    bytes    context = 1;
    DataType type    = 2;
    DtValue  value   = 3;
}

/*
 * =============== UPDATE =================
 */

/*
 * An operation to update a Counter, either on its own or inside a
 * Map. The `increment` field can be positive or negative. When absent,
 * the meaning is an increment by 1.
 */
message CounterOp {
    sint64 increment = 1;
}

/*
 * An operation to update a Set, either on its own or inside a Map.
 * Set members are opaque binary values, you can only add or remove
 * them from a Set.
 */
message SetOp {
    repeated bytes adds    = 1;
    repeated bytes removes = 2;
}

/*
 * An operation to update a Hyperloglog Set, a top-level DT.
 * You can only add to a HllSet.
 */
message HllOp {
    repeated bytes adds    = 1;
}

/*
 * An operation to be applied to a value stored in a Map -- the
 * contents of an UPDATE operation. The operation field that is
 * present depends on the type of the field to which it is applied.
 */
message MapUpdate {
    /*
     * Flags only exist inside Maps and can only be enabled or
     * disabled, and there are no arguments to the operations.
     */
    enum FlagOp {
        DEFAULT = 0;
        ENABLE  = 1;
        DISABLE = 2;
    }

    MapField  field       = 1;

    CounterOp counter_op  = 2;
    SetOp     set_op      = 3;

    /*
     * There is only one operation on a register, which is to set its
     * value, therefore the "operation" is the new value.
     */
    bytes     register_op = 4;
    FlagOp    flag_op     = 5;
    MapOp     map_op      = 6;
}

/*
 * An operation to update a Map. All operations apply to individual
 * fields in the Map.
 */
message MapOp {
    /*
     *  REMOVE removes a field and value from the Map.
     * UPDATE applies type-specific
     * operations to the values stored in the Map.
     */
    repeated MapField  removes = 1;
    repeated MapUpdate updates = 2;
}

/*
 * A "union" type for update operations. The included operation
 * depends on the datatype being updated.
 */
message DtOp {
    CounterOp counter_op = 1;
    SetOp     set_op     = 2;
    MapOp     map_op     = 3;

    /* Adding values to a hyperloglog (set) is just like adding values
     * to a set.
     */
    HllOp     hll_op     = 4;
}

/*
 * The equivalent of KV's "RpbPutReq", results in an empty response or
 * "DtUpdateResp" if `return_body` is specified, or the key is
 * assigned by the server. The request-time options are limited to
 * ones that are relevant to structured data-types.
 */
message DtUpdateReq {
    // The identifier
    bytes bucket = 1;
    bytes key    = 2; // missing key results in server-assigned key, like KV
    bytes type   = 3; // bucket type, not data-type (but the data-type is constrained per bucket-type)

    // Opaque update-context
    bytes context = 4;

    // The operations
    DtOp  op = 5;

    // Request options
    uint32 w               =  6;
    uint32 dw              =  7;
    uint32 pw              =  8;
    bool   return_body     =  9;
    uint32 timeout         = 10;
    bool   sloppy_quorum   = 11;  // Experimental, may change/disappear
    uint32 n_val           = 12;  // Experimental, may change/disappear
    bool   include_context = 13; // When return_body is true, should the context be returned too?
}


/*
 * The equivalent of KV's "RpbPutResp", contains the assigned key if
 * it was assigned by the server, and the resulting value and context
 * if return_body was set.
 */
message DtUpdateResp {
    // The key, if assigned by the server
    bytes    key           = 1;

    // The opaque update context and value, if return_body was set.
    bytes    context       = 2;
    sint64   counter_value = 3;
    repeated bytes    set_value     = 4;
    repeated MapEntry map_value     = 5;
    uint64   hll_value     = 6;
}
